#!/usr/bin/python
# DO NOT REMOVE THIS LINE - coding: utf-8

# This is the DUT test executive, runs on the target.
import traceback, os, sys, httplib, urllib, getopt, subprocess, threading, signal

# Things we say, in various lanuages
test_in_progress=("Test in progress", "Pruebas en curso", "正在测试中" )
test_passed     =("Test Passed",      "Prueba aprobada",  "通过测试"  )
test_failed     =("Test Failed",      "Prueba fallida" ,  "测试失败"  )

# Given one of the strings above, return array of languages of interest
# In this case, English and Chinese
def language(s): return [s[0],s[2]]

# parse options
try:
    opts, args = getopt.getopt(sys.argv[1:],'p:t:n')
except:
    print """\
Usage:

    dodiags [options] buildID deviceID

Interact with factory server and perform diagnostics. Options are:

    -p ip.ad.re.ss    - pionic IP address, default is "192.168.111.1"
    -t path           - path to downloaded test lists and executables, default is "./"
    -n                - register deviceID as a new device, i.e. force phase 1 operation

The caller must always provide the build ID.

The caller also provides the device ID if programmed. If not given, dodiag will
attempt to read it from the nominal device ID file, and if that fails it will
scan the PCB barcode and use that as the device ID. 

A phase 1 diagnostic must program DEVICEID from the environment into long term
storage where the caller can find it.
"""
    sys.exit(1)

if len(args) != 2: raise Exception("Must specify buildID and deviceID")

buildID=args[0]                 
deviceID=args[1]

pionicIP="192.168.111.1"        # IP address of pionic controller
forcenew=False                  # if set, register as device as "newdevice"
script_path="."                 # path to phaseX scripts

for opt, arg in opts:
    if opt == '-p': pionicIP=arg
    elif opt == '-t': script_path=arg.rstrip("/") 
    elif opt == '-n': forcenew=True 

class PionicFail(Exception): pass
# Send a request to the pionic controller, return response 
# If data is provided, it is will sent as raw POST content
def pionic(request, data=None, debug=0):
    c=httplib.HTTPConnection(pionicIP)
    c.set_debuglevel(debug)
    if data is None:
        c.request("GET","/"+request)
    else:
        c.request("POST","/"+request,data)
    r=c.getresponse()
    if r.status != 200:
        raise PionicFail("%s in service %s" % (r.reason, request))
    return r.read().strip()    

# display message in center or top-left of screen
def badge(text, fg="white", bg="blue", size=90):
    if text is None:
        pionic("display?clear&fg=%s&bg=%s"%(fg,bg))
    else:
        pionic("display?text&badge&size=%s&fg=%s&bg=%s"%(size,fg,bg), text)

# wrap text to 42 columns
def wrap(text): return reduce(lambda line, word: '%s%s%s' % (line, ' \n'[(len(line)-line.rfind('\n')-1 + len(word.split('\n',1)[0]) >= 42)], word), text.split(' '))

def report(text, fg="white", bg="blue", size=30):
    pionic("display?text&size=%d&fg=%s&bg=%s"%(size,fg,bg),wrap(text))

# request service from factory server via pionic port 61080
class FactoryFail(Exception): pass
def factory(service, options={}, debug=0):
    options["service"]=service
    c=httplib.HTTPConnection(pionicIP,port=61080)
    c.set_debuglevel(debug)
    options=urllib.urlencode(options)
    if len(options)<512:
        # Prefer GET so there's a log, but use POST if the URL is very long
        c.request("GET","/cgi-bin/factory?%s"%options)
    else:
        c.request("POST","/cgi-bin/factory", options, {"Content-Type":"application/x-www-form-urlencoded"})
    r=c.getresponse()
    if r.status != 200:
        raise FactoryFail("Service %s failed with '%s'" % (service, r.reason))
    return r.read().strip()    

# perform an arbitrary shell command with timeout, return exit status and
# command's stdout/stderr
def perform(command, timeout):
    print "Starting '%s' for max %d seconds..." % (command, timeout)
    # Support any shell command, let the shell be session leader so os.killpg can kill it and its children
    # Note we also add script_path to the PATH
    p = subprocess.Popen(["/bin/sh","-c",command],stdout=subprocess.PIPE,stderr=subprocess.STDOUT, preexec_fn=os.setsid, env=dict(os.environ,PATH=script_path+os.pathsep+os.environ["PATH"]))
    t = threading.Timer(timeout, os.killpg, (p.pid, signal.SIGKILL))
    try:
        t.start()
        stdout = p.communicate()[0]
    finally:
        expired=not t.isAlive()
        t.cancel()
    p.stdout.close()
    stdout=stdout.strip()
    if not stdout: stdout="NO OUTPUT\n"  
    status=p.returncode
    if expired:
        stdout+="\nTIMEOUT\n"
        if not status: status=-99
    print "Status:",status
    print "Stdout:"    
    for l in stdout.splitlines(): print "  ",l
    return (status, stdout)

# This is the main test loop
try:
    badge("\n".join(language(test_in_progress)))

    print "Build ID is", buildID
    print "Device ID is", deviceID    
    print "Pionic IP is", pionicIP 

    if forcenew:
        factory("newdevice",{"deviceid":deviceID, "buildid": buildID})
    
    # Pass info to test processes in the environment
    os.environ["PIONICIP"]=pionicIP
    os.environ["BUILDID"]=buildID
    os.environ["DEVICEID"]=deviceID 

    phase, sessionID = factory("startsession",{"deviceid":deviceID, "buildid":buildID}).split()[0:2]

    script="%s/phase%s" % (script_path, phase)
    print "Using test list %s" % script

    # flags that can be set or cleared by testlist
    flags={"IgnoreFail":False}

    # Parse the test list file in a list of dicts.   
    # A dict may contain:
    #   {"op":"test", "testname":"s", "timeout":N, "command":"s"}   - execute command with timeout
    #   {"op":"push", "count":N}                                    - push a new loop count
    #   {"op":"dbnz", "index",I}                                    - decrement the loop count, if zero pop the loop count and continue. Else branch to specified index.
    #   {"op":"set", "flag":"name"}                                 - set named flag
    #   {"op":"clear", "flag":"name"}                               - clear named flag
    operation=[]
    pushed=[]
    line=0
    class ParseFail(Exception): 
        def __init__(self, args):
            Exception.__init__("%s line %d - %s" % (script, line, format(args)))
    for l in open(script):
        line+=1
        l=l.split('#')[0].strip()
        if not l: continue
        if ":" in l:
            # name : timeout : command
            t=l.split(':',2)
            if len(t) != 3: raise ParseFail("expected at least 3 colons")
            testname=" ".join(t[0].split())
            if not testname: raise ParseFail("expected a test name")
            try:
                timeout=int(t[1].strip() or "60")
                if (timeout <= 0): raise ValueError
            except ValueError:
                raise ParseFail("timeout is invalid")
            command=" ".join(t[2].split())
            if not command: raise ParseFail("expected a command string")
            # catch too many ::'s
            if command.startswith(":"): raise ParseFail("command can't start with colon")
            operation.append({"op":"test", "testname":testname, "timeout":timeout, "command":command})
        elif "{" in l:
            # count {
            t=l.split("{",1)
            if t[1]: raise ParseFail("unexpected text after '{'")
            try:
                count=int(t[0].strip())
            except ValueError:
                raise ParseFail("loop count is invalid")
            operation.append({"op":"push", "count":count})
            pushed.append(len(operation))
        elif l == "}":
            if not pushed: raise ParseFail("'unexpected '}'")
            operation.append({"op":"dbnz", "index":pushed.pop()})
        else:
            t=l.split()
            if t[0] == "set" or t[0] == "clear":
                if len(t) != 2 or not t[1] in flags: raise ParseFail("flag name is invalid")
                operation.append({"op":t[0],"flag":t[1]})
            else:
                raise ParseFail("line is invalid")
            
    if pushed: raise ParseFail("Missing '}'")             
    if not operation: raise ParseFail("Nothing to do!")
    
    # ok, now iterate the operation list
    class TestFail(Exception): pass
    pushed=[]   # pushed loop counters
    index=0     # current operation index
    failing=0   # remember failure when IgnoreFail is set
    while index < len(operation):
        op=operation[index]["op"]
        if op == "test":
            testname=operation[index]["testname"]
            timeout=operation[index]["timeout"]
            command=operation[index]["command"]
            report("\n".join(language(test_in_progress)) +
                   "\n\n" +
                   "Device ID : %s\n" % deviceID +
                   "Build ID  : %s\n" % buildID +
                   "Phase     : %s\n" % phase +
                   "Test      : %s\n" % testname +
                   "Timeout   : %s\n" % timeout +
                   "Command   : %s\n" % command,
                   bg="purple" if failing else "blue")
            testid=factory("starttest", {"deviceid":deviceID, "testname":testname, "command":command})
            status, stdout=perform(command, timeout)
            factory("endtest", {"deviceid":deviceID, "testid":testid, "status":status, "stdout":stdout})
            if status:
                if not flags["IgnoreFail"]: break
                failing=1
        elif op == "push":
            pushed.append(operation[index]["count"])
        elif op == "dbnz":
            pushed[-1] -= 1
            if pushed[-1]:
                index=operation[index]["index"]-1 # will be incremented soon
            else:
                pushed.pop()
        elif op == "set":
            flags[operation[index]["flag"]]=True
        elif op == "clear":    
            flags[operation[index]["flag"]]=False
        else:
            raise Exception("shouldn't get here")
        # advance to next operation
        index+=1

    # we're done, end session!
    state = factory("endsession", {"deviceid":deviceID, "sessionid":sessionID}).split()[0]

    failed = (state != "PASSED" and state != "COMPLETE")

    report("\n".join(language(test_failed if failed else test_passed)) +
           "\n\n" +
           "Device ID : %s\n" % deviceID +
           "Build ID  : %s\n" % buildID +
           "Phase     : %s\n" % phase +
           ("\nALL TESTS COMPLETE!" if state == "COMPLETED" else ""),
           bg="red" if failed else "green")
    try:
        sys.exit(failed)
    except:
        pass

except:
    t,v,tb=sys.exc_info()
    traceback.print_exc()
    report("\n".join(language(test_failed))+"\n\n%s@%d: %s" % (t.__name__,tb.tb_lineno,str(v)), bg="red", fg="white")
    sys.exit(1)
