#!/usr/bin/python
# DO NOT REMOVE THIS LINE - coding: utf-8

# This is the test client

import traceback, os, sys, httplib, time, urllib, getopt, subprocess, threading, signal


def die(msg):
    print msg
    sys.exit(1)

buildID=None
deviceID=None
pionicIP="192.168.111.1"
serverIP=None
id_file="./deviceid.txt"
script_path="."

# parse options
try:
    opts, args = getopt.getopt(sys.argv[1:],'p:s:i:t:')
except:
    die("""\
Usage:

    dodiags [options] buildID [deviceID]

Interact with factory server and perform diagnostics. Options are:

    -p ip.ad.re.ss    - specify pionic IP address, default is "192.168.111.1"
    -s ip.ad.re.ss    - specify factory server IP address, default is to request it from pionic
    -i /path/to/file  - specify file containing the device ID string, default is "./deviceid.txt"
    -t path           - specify path to "phaseX" test lists, default './' 

The caller must always provide the build ID.

The caller also provides the device ID if programmed. If not given, dodiag will
attempt to read it from the nominal device ID file, and if that fails it will
scan the PCB barcode and use that as the device ID, and will update the file.

In theory one of the phase 1 diagnostics installs the device ID into permanent
storage if it doesn't already exist, so that it can thereafter be provided by
the caller.

""")

if len(args) < 1 or len(args) > 2: die("Must specify build ID")

buildID=args[0]
if len(args) > 1: deviceID=args[1]

for opt, arg in opts:
    if opt == '-p': pionicIP=arg
    if opt == '-s': serverIP=arg
    if opt == '-i': id_file=arg
    if opt == '-t': scriptpath=arg.rstrip("/"); 

class PionicFail(Exception): pass
# Send a request to the pionic controller, return response 
# The IP of the pionic controller is hard coded
# If data is provided, it is will sent as raw POST content
def pionic(request, data=None, debug=0):
    c=httplib.HTTPConnection(pionicIP);
    c.set_debuglevel(debug)
    if data is None:
        c.request("GET","/"+request)
    else:
        c.request("POST","/"+request,data)
    r=c.getresponse()
    if r.status != 200:
        raise PionicFail("%s in service %s" % (r.reason, request))
    return r.read().strip()    

# display message in center or top-left of screen
def badge(text, fg="white", bg="blue", size=90):
    pionic("display?text&badge&size=%s&fg=%s&bg=%s"%(size,fg,bg), text)

# wrap text to 40 columns
def wrap(text): return reduce(lambda line, word: '%s%s%s' % (line, ' \n'[(len(line)-line.rfind('\n')-1 + len(word.split('\n',1)[0]) >= 40)], word), text.split(' '))

def report(text, fg="white", bg="blue", size=30):
    pionic("display?text&size=%d&fg=%s&bg=%s"%(size,fg,bg),wrap(text));

# request factory service from serverIP
class ServerFail(Exception): pass
def server(service, options={}, debug=0):
    options["service"]=service;
    c=httplib.HTTPConnection(serverIP);
    c.set_debuglevel(debug)
    options=urllib.urlencode(options)
    if len(options)>256:
        # Prefer get so we have a log, but use post if URL is very long
        c.request("POST","/cgi-bin/factory", options, {"Content-Type":"application/x-www-form-urlencoded"})
    else:
        c.request("GET","/cgi-bin/factory?%s"%options)
    r=c.getresponse()
    if r.status != 200:
        raise ServerFail("%s in service %s" % (r.reason, service))
    return r.read().strip()    

def save_deviceID(deviceID):
    print "Writing %s to %s..." % (deviceID, id_file) 
    with open(id_file,"w") as f: f.write(deviceID)

def load_deviceID():
    deviceID=None	
    try:
	with open(id_file,"r") as f: deviceID=f.readline().strip()
    except:
	pass
    if deviceID == "": deviceID = None
    return deviceID

def perform(command, timeout):
    print "Starting '%s' for max %d seconds..." % (command, timeout)
    # Support any shell command, let the shell be session leader so os.killpg can kill it and its children
    p = subprocess.Popen(["/bin/sh","-c",command],stdout=subprocess.PIPE,stderr=subprocess.STDOUT, preexec_fn=os.setsid)
    t = threading.Timer(timeout, os.killpg, (p.pid, signal.SIGKILL))
    try:
        t.start()
        stdout = p.communicate()[0]
    finally:
        expired=not t.isAlive()
        t.cancel()
    p.stdout.close()
    status=p.returncode
    if expired:
        stdout=stdout+"\nTIMEOUT"
        if not status: status=-99
    if stdout=="": stdout="No output"    
    print "Output:"    
    for l in stdout.splitlines(): print ">",l
    print "Exit status:",status
    return (status, stdout)


class TestFail(Exception): pass
try:
    badge("Test in progress\n正在测试中")

    print "Build ID is", buildID

    print "Pionic IP is", pionicIP 

    if serverIP is None:
        print "Factory IP unknown, requesting from pionic"
        serverIP=pionic("factory")
    print "Server IP is",serverIP

    if deviceID is None: deviceID = load_deviceID()
    if deviceID is None:
        print "Provisioning deviceID"
        server("newdevice",{"buildid": buildID})
        badge("Scan barcode\n扫描条形码", fg="black", bg="yellow")
        deviceID=pionic("getbar")
        badge("Test in progress\n正在测试中")
	print "Got device ID, updating server",deviceID
        server("newdevice",{"deviceid":deviceID, "buildid": buildID})
        save_deviceID(deviceID)
    print "Device ID is", deviceID    

    phase=server("startdiag",{"deviceid":deviceID, "buildid":buildID})

    script="%s/phase%s" % (script_path, phase)
    print "Using script %s"%(script,)
    line=0
    for l in open(script):
        line+=1
        l=l.split('#',1)[0].strip()
        if l == "": continue
        print "Line %d: %s" % (line,l)
        t=l.split(':',2)
        if len(t) != 3: raise TestFail("%s line %d is invalid!" % (script, line))
        testname=" ".join(t[0].split())
        if testname=="": raise TestFail("Null test name in %s line %d" % (script, line))
        try:
            timeout=int(t[1] if t[1] else "60")
            if (timeout <= 0): raise Exception
        except:
            raise TestFail("Invalid timeout in %s line %s" % (script, line))
        command=" ".join(t[2].split())
        if command == "": raise TestFail("Null command in %s line %d" % (script, line))
        if command.find(":") == 0: raise TestFail("Command starts with colon in %s line %d" % (script, line))
        report(("Test in progress - 正在测试中\n"+
                "Device ID : %s\n"+
                "Build ID  : %s\n"+
                "Phase     : %s\n"+
                "Test      : %s\n"+
                "Timeout   : %s\n"+
                "Command   : %s\n") % (deviceID, buildID, phase, testname, timeout, command))
        testid=server("starttest", {"deviceid":deviceID, "testname":testname, "command":command})
        status, stdout=perform(command, timeout)
        server("endtest", {"deviceid":deviceID, "testid":testid, "status":status, "stdout":stdout})
        if status: raise TestFail("'%s' exit status %d (%s line %d)" % (testname, status, script, line))

    server("enddiag", {"deviceid":deviceID})

    badge(deviceID+"\nTEST PASSED\n通过测试", bg="green");

except:
    traceback.print_exc()
    t,v,tb=sys.exc_info()
    report("TEST FAILED - 测试失败\n\n%s@%d: %s" % (t.__name__,tb.tb_lineno,str(v)), bg="red", fg="white")

