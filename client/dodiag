#!/usr/bin/python
# DO NOT REMOVE THIS LINE - coding: utf-8

# This is the test client

import traceback, os, sys, httplib, time, urllib, getopt, subprocess, threading, shlex

def die(msg):
    print msg
    sys.exit(1)

buildID=None
deviceID=None
pionicIP="192.168.111.1"
factoryIP=None
id_file="/tmp/deviceid.txt"

# parse options
try:
    opts, args = getopt.getopt(sys.argv[1:],'p:f:')
except:
    die("""\
Usage:

    dodiags [options] buildID [deviceID]

Interact with factory server and perform diagnostics. Options are:

    -p ip.ad.re.ss    - specify pionic IP address, default is '192.168.111.1'
    -f ip.ad.re.ss    - specify factory server IP address, default is to request it from pionic
    -d /path/to/file  - specify file containing the device ID string, default '/tmp/deviceid.txt'

The build ID must always be provided. 

If device ID is not provided dodiag will attempt to read it from the nominal
device ID file. If that fails it will proceed to scan the PCB barcode to use
that as the device ID, incidentally also updating the file.

In theory one of the phase 1 diagnostics installs the device ID into permanent
storage as required.

dodiags expects to find text files named "phase1", "phase2" in the current directory. 


""")

if len(args) < 1 or len(args) > 2: die("Must specify build ID")

buildID=args[0]
if len(args) > 1: deviceID=args[1]

for opt, arg in opts:
    if opt == '-p': pionicIP=arg
    if opt == '-f': factoryIP=arg

# Send a request to the pionic controller, return response 
# The IP of the pionic controller is hard coded
# If data is provided, it is will sent as raw POST content
def pionic(request, data=None, debug=0):
    c=httplib.HTTPConnection(pionicIP);
    c.set_debuglevel(debug)
    if data is None:
        c.request("GET","/"+request)
    else:
        c.request("POST","/"+request,data)
    r=c.getresponse()
    if r.status != 200:
        raise Exception("Pionic request failed: %s" % (r.reason,))
    return r.read().strip()    

# display message in center or top-left of screen
def badge(text, fg="white", bg="blue", size=90):
    pionic("display?text&badge&size=%s&fg=%s&bg=%s"%(size,fg,bg), text)

def report(text, fg="white", bg="blue", size=30):
    pionic("display?text&size=%d&fg=%s&bg=%s"%(size,fg,bg),text);

# request factory service from factoryIP
def factory(service, options={}, stdout=None, debug=0):
    options["service"]=service;
    c=httplib.HTTPConnection(factoryIP);
    c.set_debuglevel(debug)
    options=urllib.urlencode(options)
    if len(options)>80:
        # use post if url is too long
        c.request("POST","/cgi-bin/factory", options, {"Content-Type":"application/x-www-form-urlencoded"})
    else:
        c.request("GET","/cgi-bin/factory?%s"%options)
    r=c.getresponse()
    if r.status != 200:
        raise Exception("Factory service %s failed: %s" % (service, r.reason))
    return r.read().strip()    

def save_deviceID(deviceID):
    try:
        with open(id_file) as f: f.write(deviceID)
    except:
	pass

def load_deviceID():
    deviceID=None	
    try:
	with open(id_file) as f: deviceID=f.readline().strip()
	if deviceID == "": deviceID = None
    except:
	pass
    return deviceID

def perform(command, timeout):
    # Support any shell command, let the shell be session leader so we can kill it and all its children
    p = subprocess.Popen(["/bin/sh","-c",command],stdout=PIPE,stderr=subprocess.STDOUT, preexec_fn=os.setsid)
    t = threading.timer(timeout, os.killpg, (p.pid, signal.SIGKILL))
    try:
        t.start()
        stdout = p.communicate()[0]
    finally:
        expired=not t.isAlive()
        t.cancel()
    p.stdout.close()
    status=p.returncode
    if expired: 
        stdout=stdout+"\nTIMEOUT"
        if not status: status=-99
    return (status, stdout)

try:
    badge("Test in progress\n正在测试中")

    print "Build ID is", buildID

    print "Pionic IP is", pionicIP 

    if factoryIP is None:
        print "Factory IP unknown, requesting from pionic"
        factoryIP=pionic("factory")
    print "Factory IP is",factoryIP

    if deviceID is None: deviceID = load_deviceID()
    if deviceID is None:
        print "Provisioning deviceID"
        factory("newdevice",{"buildid": buildID})
        badge("Scan barcode\n扫描条形码", fg="black", bg="yellow")
        deviceID=pionic("getbar")
        badge("Test in progress\n正在测试中")
	print "Got device ID, updating server",deviceID
        factory("newdevice",{"deviceid":deviceID, "buildid": buildID})
        print "Updating device ID file" 
        with open("/tmp/dodiag.deviceID.txt","w") as f: f.write(deviceID)
    print "Device ID is", deviceID    

    phase=factory("startdiag",{"deviceid":deviceID, "buildid":buildID})

    print "Performing phase %s tests"%phase
    for l in open("phase%s" % phase):
        l=l.split('#',2)[0].strip()
        if l == "": continue
        print "Found '%s'" % (l,) 
        t=l.split(':',3)
        if len(t) != 3: raise Exception("Invalid line in phase%d: '%s'"%(phase,l))
        testname=" ".join(t[0].split())
        timeout=int(t[1] if t[1] else "0")
        if not timeout: timeout=60
        command=" ".join(t[2].split())
        report(("Test in progress - 正在测试中\n"+
                "Device ID : %s\n"+
                "Build ID  : %s\n"+
                "Phase     : %s\n"+
                "Test      : %s\n"+
                "Timeout   : %s\n"+
                "Command   : %s\n") % (deviceID, buildID, phase, testname, timeout, command))
        testid=factory("starttest", {"deviceid":deviceID, "testname":testname, "command":command})
        print "Starting '%s' for max %d seconds..." % (command, timeout)
        status, stdout=perform(command, timeout)
        factory("endtest", {"deviceid":deviceID, "testid":testid, "status":status, "stdout":stdout})

    factory("enddiag", {"deviceid":deviceID})

    badge(deviceID+"\nTEST PASSED\n通过测试", bg="green");

except Exception as e:
    report("TEST FAILED - 测试失败\n\n"+traceback.format_exc(), bg="red", fg="white")

