#!/usr/bin/python
# DO NOT REMOVE THIS LINE - coding: utf-8

# This is the DUT test executive, runs on the target.
import traceback, os, sys, httplib, urllib, getopt, subprocess, threading, signal

buildID=None                    # must be specified on command line
deviceID=None                   # can be specified, otherwise we'll try to discover it
id_file="./deviceid.txt"        # file to read or write when deviceID not explicitly given
pionicIP="192.168.111.1"        # IP address of pionic controller
serverIP=None                   # IP address of the factory server                      
script_path="."                 # Path to phaseX scripts

# parse options
try:
    opts, args = getopt.getopt(sys.argv[1:],'p:s:i:t:')
except:
    print """\
Usage:

    dodiags [options] buildID [deviceID]

Interact with factory server and perform diagnostics. Options are:

    -p ip.ad.re.ss    - pionic IP address, default is "192.168.111.1"
    -s ip.ad.re.ss    - factory server IP address, default is to request it from pionic
    -i /path/to/file  - file to write deviceID if not given on the command line, default is "./deviceid.txt"
    -t path           - path to "phaseX" test lists, default './' 

The caller must always provide the build ID.

The caller also provides the device ID if programmed. If not given, dodiag will
attempt to read it from the nominal device ID file, and if that fails it will
scan the PCB barcode and use that as the device ID, and will update the file.

In theory one of the phase 1 diagnostics installs the device ID into permanent
storage if it doesn't already exist, so that it can thereafter be provided by
the caller.
"""
    sys.exit(1)

if len(args) < 1 or len(args) > 2: raise Exception("Build ID not specified")

buildID=args[0]
if len(args) > 1: deviceID=args[1]

for opt, arg in opts:
    if opt == '-p': pionicIP=arg
    elif opt == '-s': serverIP=arg
    elif opt == '-i': id_file=arg
    elif opt == '-t': scriptpath=arg.rstrip("/"); 

class PionicFail(Exception): pass
# Send a request to the pionic controller, return response 
# The IP of the pionic controller is hard coded
# If data is provided, it is will sent as raw POST content
def pionic(request, data=None, debug=0):
    c=httplib.HTTPConnection(pionicIP)
    c.set_debuglevel(debug)
    if data is None:
        c.request("GET","/"+request)
    else:
        c.request("POST","/"+request,data)
    r=c.getresponse()
    if r.status != 200:
        raise PionicFail("%s in service %s" % (r.reason, request))
    return r.read().strip()    

# display message in center or top-left of screen
def badge(text, fg="white", bg="blue", size=90):
    if text is None:
        pionic("display?clear&fg=%s&bg=%s"%(fg,bg))
    else:
        pionic("display?text&badge&size=%s&fg=%s&bg=%s"%(size,fg,bg), text)

# wrap text to 40 columns
def wrap(text): return reduce(lambda line, word: '%s%s%s' % (line, ' \n'[(len(line)-line.rfind('\n')-1 + len(word.split('\n',1)[0]) >= 40)], word), text.split(' '))

def report(text, fg="white", bg="blue", size=30):
    pionic("display?text&size=%d&fg=%s&bg=%s"%(size,fg,bg),wrap(text))

# request factory service from serverIP
class ServerFail(Exception): pass
def server(service, options={}, debug=0):
    options["service"]=service
    c=httplib.HTTPConnection(serverIP)
    c.set_debuglevel(debug)
    options=urllib.urlencode(options)
    if len(options)<512:
        # Prefer GET so there's a log, but use POST if the URL is very long
        c.request("GET","/cgi-bin/factory?%s"%options)
    else:
        c.request("POST","/cgi-bin/factory", options, {"Content-Type":"application/x-www-form-urlencoded"})
    r=c.getresponse()
    if r.status != 200:
        raise ServerFail("Service %s failed with '%s'" % (service, r.reason))
    return r.read().strip()    

# perform an arbitrary shell command with timeout, return exit status and
# command's stdout/stderr
def perform(command, timeout):
    print "Starting '%s' for max %d seconds..." % (command, timeout)
    # Support any shell command, let the shell be session leader so os.killpg can kill it and its children
    p = subprocess.Popen(["/bin/sh","-c",command],stdout=subprocess.PIPE,stderr=subprocess.STDOUT, preexec_fn=os.setsid)
    t = threading.Timer(timeout, os.killpg, (p.pid, signal.SIGKILL))
    try:
        t.start()
        stdout = p.communicate()[0]
    finally:
        expired=not t.isAlive()
        t.cancel()
    p.stdout.close()
    status=p.returncode
    if expired:
        stdout=stdout+"\nTIMEOUT"
        if not status: status=-99
    if stdout=="": stdout="No output"    
    print "Output:"    
    for l in stdout.splitlines(): print ">",l
    print "Exit status:",status
    return (status, stdout)


# This is the main test loop
class TestFail(Exception): pass
try:
    badge("Test in progress\n正在测试中")

    print "Build ID is", buildID
    print "Pionic IP is", pionicIP 

    if serverIP is None:
        print "Factory IP unknown, requesting from pionic"
        serverIP=pionic("factory")
    print "Server IP is",serverIP

    if deviceID is None:
        print "Proivisioning deviceID"
        server("newdevice",{"buildid": buildID})
        badge("Scan barcode\n扫描条形码", fg="black", bg="yellow")
        deviceID=pionic("getbar")
        badge(None)
	print "Got %s, updating server" % (deviceID,)
        server("newdevice",{"deviceid":deviceID, "buildid": buildID})
        # write to a file for later
        print "Updating %s..." % (id_file,)
        with open(id_file,"w") as f: f.write(deviceID)
    
    print "Device ID is", deviceID    

    phase=server("startdiag",{"deviceid":deviceID, "buildid":buildID})

    script="%s/phase%s" % (script_path, phase)
    print "Using script %s"%(script,)
    line=0
    for l in open(script):
        line+=1
        l=l.split('#',1)[0].strip()
        if l == "": continue
        print "Line %d: %s" % (line,l)
        t=l.split(':',2)
        if len(t) != 3: raise TestFail("%s line %d is invalid!" % (script, line))
        testname=" ".join(t[0].split())
        if testname=="": raise TestFail("Null test name in %s line %d" % (script, line))
        try:
            timeout=int(t[1] if t[1] else "60")
            if (timeout <= 0): raise Exception
        except:
            raise TestFail("Invalid timeout in %s line %s" % (script, line))
        command=" ".join(t[2].split())
        if command == "": raise TestFail("Null command in %s line %d" % (script, line))
        if command.find(":") == 0: raise TestFail("Command starts with colon in %s line %d" % (script, line))
        report(("Test in progress - 正在测试中\n"+
                "Device ID : %s\n"+
                "Build ID  : %s\n"+
                "Phase     : %s\n"+
                "Test      : %s\n"+
                "Timeout   : %s\n"+
                "Command   : %s\n") % (deviceID, buildID, phase, testname, timeout, command))
        testid=server("starttest", {"deviceid":deviceID, "testname":testname, "command":command})
        status, stdout=perform(command, timeout)
        server("endtest", {"deviceid":deviceID, "testid":testid, "status":status, "stdout":stdout})
        if status: raise TestFail("'%s' exit status %d (%s line %d)" % (testname, status, script, line))

    server("enddiag", {"deviceid":deviceID})

    badge(deviceID+"\nTEST PASSED\n通过测试", bg="green")

except:
    traceback.print_exc()
    t,v,tb=sys.exc_info()
    report("TEST FAILED - 测试失败\n\n%s@%d: %s" % (t.__name__,tb.tb_lineno,str(v)), bg="red", fg="white")

